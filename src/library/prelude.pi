-- NOTE: Many of these functions could benefit from implicit arguments for
-- improved ergonomics. For example, the identity function could be written as:
--
-- ```
-- id : {a : Type} -> a -> a;
-- id x = x;
-- ```
--
-- This would then allow one to write:
--
-- ```
-- Pikelet> id "hello"
-- "hello" : String
-- ```

||| The polymorphic identity function
id : (a : Type) -> a -> a;
id a x = x;

||| Creates a function that always returns the same value
const : (a b : Type) -> a -> b -> a;
const a b x y = x;

||| Function composition
compose : (a b c : Type) -> (b -> c) -> (a -> b) -> (a -> c);
compose a b c f g x = f (g x);

||| Flip the order of the first two arguments to a function
flip : (a b c : Type) -> (a -> b -> c) -> (b -> a -> c);
flip a b c f x y = f y x;


||| Logical absurdity
|||
||| This type should have no inhabitants - if it does, it's a bug in our
||| typechecker!
void : Type 1;
void = (a : Type) -> a;


||| Logical negation
not : Type -> Type 1;
not a = a -> void;


unit : Type 1;
unit = (a : Type) -> a -> a;

unit-intro : unit;
unit-intro = id;

unit-elim : (a : Type) -> unit -> a -> a;
unit-elim a f x = f a x;


||| Logical conjunction (Church encoded)
|||
||| You could also interpret this as a product type
and : Type -> Type -> Type 1;
and p q = (c : Type) -> (p -> q -> c) -> c;

||| Introduce a logical conjunction between two types
and-intro : (p q : Type) -> p -> q -> and p q;
and-intro p q x y c f = f x y;

-- FIXME: These don't typecheck - I might have got the definitions wrong, or
-- there is a bug in the type checker!

-- and-elim-left : (p q : Type) -> and p q -> p;
-- and-elim-left p q (pq : and p q) = pq p const;

-- and-elim-right : (p q : Type) -> and p q -> q;
-- and-elim-right p q (pq : and p q) = pq p (flip const);


||| Logical disjunction (Church encoded)
|||
||| You could also interpret this as a sum type
or : Type -> Type -> Type 1;
or p q = (c : Type) -> (p -> c) -> (q -> c) -> c;

-- FIXME: These don't typecheck - I might have got the definitions wrong, or
-- there is a bug in the type checker!

-- or-intro-left : (p q : Type) -> p -> or p q;
-- or-intro-left p q (x : p) c (on-p : p -> c) (on-q : q -> c) = on-p x;

-- or-intro-right : (p q : Type) -> q -> or p q;
-- or-intro-right p q (y : q) c (on-p : p -> c) (on-q : q -> c) = on-q y;


||| Dependent products
Prod : (A : Type) (B : A -> Type) -> Type;
Prod A B = (a : A) -> B a;

||| Dependent sums (subtypes)
Sum : (A : Type) (B : A -> Type) -> Type;
Sum A B = Record {
    val : A,
    proof : B val,
};


||| Module for defining equality between two terms
Eq (a : Type) = Record {
    ||| Compare two terms for equality
    eq : a -> a -> Bool,
};

||| Compare two terms for equality
eq : (a : Type) (EQ : Eq a) -> a -> a -> Bool;
eq _ EQ = EQ.eq;


Eq-Bool : Eq Bool;
Eq-Bool = record {
    eq lhs rhs =
        if lhs then rhs else
            (if rhs then false else true),
};


||| An associative operation on `a`.
|||
||| This means the following laws must hold:
|||
||| ```
||| (a : Type) (S : Semigroup a) (x y z: a) ->
|||     S.append x (S.append y z) == S.append (S.append x y) z
||| ```
Semigroup (a : Type) = Record {
    ||| The associative operation
    append : a -> a -> a,

    -- TODO: Laws via quickcheck or proofs?
};

append : (a : Type) (S : Semigroup a) -> a -> a -> a;
append _ S = S.append;


||| A semigroup that also has an identity.
|||
||| This means the following additional laws must hold:
|||
||| ```
||| (a : Type) (M : Monoid a) (x : a) -> M.semigroup.append x M.empty == x
||| (a : Type) (M : Monoid a) (x : a) -> M.semigroup.append M.empty x == x
||| ```
Monoid (a : Type) = Record {
    ||| The semigroup
    semigroup : Semigroup a,
    ||| The identity of `.semigroup.append`
    empty : a,

    -- TODO: Laws via quickcheck or proofs?
};

empty : (a : Type) (M : Monoid a) -> a;
empty _ M = M.empty;


||| General trait for numeric types
Num (a : Type) = Record {
    ||| The additive monoid
    additive : Monoid a,
    ||| The multiplicative monoid
    multiplicative : Monoid a,
};

add : (a : Type) (N : Num a) -> a -> a -> a;
add a N = append a N.additive.semigroup;

zero : (a : Type) (N : Num a) -> a;
zero a N = empty a N.additive;

mul : (a : Type) (N : Num a) -> a -> a -> a;
mul a N = append a N.multiplicative.semigroup;

one : (a : Type) (N : Num a) -> a;
one a N = empty a N.multiplicative;


||| A category is a very general structure that provides a common way of composing
||| units of functionality
|||
||| The most common category programmers would be familiar with would be `Type`s
||| are the objects, and the functions between those types are the arrows. Many
||| other categories exist though, for example:
|||
||| - nodes in a directed graph, and the edges between those nodes.
||| - etc.
Category = Record {
    ||| An object in the category
    Object : Type 1, -- FIXME: universe polymorphism!
    ||| Arrows between the objects in the category
    Arrow : Object -> Object -> Type,
    ||| The identity arrow
    id : (a : Object) -> Arrow a a,
    ||| The sequencing of two arrows
    seq : (a b c : Object) -> Arrow a b -> Arrow b c -> Arrow a c,

    -- TODO: Laws via quickcheck or proofs?
    -- TODO: E-Category - ie. equivalence relation on morphisms?
    -- https://gist.github.com/brendanzab/9285eb8dfef5b6d6ccd87d90d6579590#gistcomment-2401643
};

||| The identity arrow
id : (C : Category) (a : C.Object) -> C.Arrow a a;
id C = C.id;

||| The sequencing of two arrows
seq : (C : Category) (a b c : C.Object) -> C.Arrow a b -> C.Arrow b c -> C.Arrow a c;
seq C = C.seq;

||| The composition of two arrows
compose : (C : Category) (a b c : C.Object) -> C.Arrow b c -> C.Arrow a b -> C.Arrow a c;
compose C a b c f g = seq C a b c g f;


Category-Function : Category = record {
    Object = Type,
    Arrow a b = a -> b,
    id (a : Type) (x : a) = x,
    seq (a b c : Type) (f : a -> b) (g : b -> c) (x : a) = g (f x),
};


||| Provides a mapping from objects-to-objects and arrows-to-arrows for two
||| categories, `Source` and `Target`
|||
||| Mappings can be anything from applying a function to each element of a
||| collection, to compiling a source language to a target language.
|||
||| Haskell programmers might find this definition a little foreign - this
||| is because we use general categories in the definition, rather than
||| specializing it into the category of Pikelet functions
Functor = Record {
    ||| The source category
    Source : Category,
    ||| The target category
    Target : Category,
    ||| Maps an object in `Source` to an object in `Target`
    Map : Source.Object -> Target.Object,
    ||| Maps an arrow in `Source` into an arrow in `Target`
    map : (a b : Source.Object) -> Source.Arrow a b -> Target.Arrow (Map a) (Map b),

    -- TODO: Laws via quickcheck or proofs?
};

||| Maps an arrow in `F.Source` into an arrow in `F.Target`
map : (F : Functor) (a b : F.Source.Object) -> F.Source.Arrow a b -> F.Target.Arrow (F.Map a) (F.Map b);
map F = F.map;


Endofunctor-Function : Functor = record {
    Source = Category-Function,
    Target = Category-Function,
    Map x = x,
    map (a b : Type) (f : a -> b) (x : a) = f x,
};
